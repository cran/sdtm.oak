<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Path to Automation</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>







<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Path to Automation</h1>



<style type="text/css">
#pkgdown-sidebar{
display:none;
}
.wide .table{
font-size: 8px;
overflow: visible
}
</style>
<p>The initial release of {sdtm.oak} provides a framework for modular
programming of SDTM in R and sets the stage for potential automation of
SDTM creation following the standardized SDTM specification. In the
future, the automation workflow could involve preparing specifications
and then making automated function calls to generate SDTM domains.</p>
<p>The future workflow for automation could look like:</p>
<ol style="list-style-type: decimal">
<li>Prepare SDTM specification: Users can define the raw data source,
target SDTM domain, target SDTM variables, and algorithms used for
automation. A template is still under development; details are also
provided in this article.</li>
<li>Prepare SDTM-controlled Terminology: Users can define the
SDTM-controlled terms applicable to the study. A template is still under
development.</li>
<li>An automated process to read the specification and make {sdtm.oak}
function calls can create the code required to generate SDTM datasets or
the datasets themselves.</li>
</ol>
<p>This article provides an overview of metadata and a draft version of
the standard SDTM specification. We plan to demonstrate the creation of
standard SDTM specs from the CDISC library in collaboration with CDISC
COSA. Sponsors may need to establish the necessary tools to generate
this SDTM specification from their MDR to utilize the automation
features of {sdtm.oak}. It’s worth mentioning that this concept draws
inspiration from Roche’s existing implementation of the SDTM automation
process using OAK. I would like to inform you that further development
is required for this concept.</p>
<p>Throughout this article, the term “metadata” is used several times.
In this context, “metadata” refers to the specific metadata used by
{sdtm.oak}. This article aims to provide users with a more detailed
understanding of the {sdtm.oak} metadata.</p>
<p>In general, metadata can be defined as “data about data.” It does not
include any patient-level data. Instead, the metadata provides a
blueprint of the data that needs to be collected during a study.</p>
<div id="standards-metadata" class="section level2">
<h2>Standards Metadata</h2>
<p>The standards metadata used in {sdtm.oak} is sourced from the CDISC
Library or sponsor MDR or any other form of documentation where
standards are maintained. This metadata provides information on the
following:</p>
<ul>
<li>The relationship between Data Collection Standards (eCRF &amp; eDT),
SDTM mapping, and Controlled Terminology</li>
<li>Machine-readable standard SDTM mappings</li>
<li>Algorithms and associated metadata required for the SDTM automation
of standards in the study.</li>
</ul>
<p>In the upcoming releases of {sdtm.oak}, we will effectively utilize
the standards metadata and customize it to meet the study
requirements.</p>
</div>
<div id="study-definition-metadata" class="section level2">
<h2>Study Definition Metadata</h2>
<p>Study Definition Metadata is also referred to as Study Metadata.
Study Definition Metadata provides information about the eCRF and eDT
data collected in the study.</p>
<p><strong>eCRF Metadata</strong> The eCRF Design Metadata is fetched
from the EDC system. This Metadata includes</p>
<ul>
<li><p>Forms Metadata: Identifier, eCRF label, Repeating format and
other properties of the eCRF.</p></li>
<li><p>Fields Metadata: Identifier, question label, datatype, and other
properties of data collection fields in the study.</p></li>
<li><p>Data Dictionaries: Identifier and the controlled terms collected
at the source.</p></li>
<li><p>Visits: Name of the visits as defined in the EDC.</p></li>
</ul>
<p><strong>eDT Metadata</strong></p>
<p>eDT Metadata is the blueprint metadata that describes the data
collected as part of that external data transfer (from clinical sites to
the sponsor). This includes</p>
<ul>
<li><p>Dataset name, label, repeating properties, etc.</p></li>
<li><p>Variable name, datatype, label and associated codelist,
etc.</p></li>
</ul>
</div>
<div id="study-sdtm-mappings-metadata-specifications" class="section level2">
<h2>Study SDTM Mappings Metadata (specifications)</h2>
<p>Study SDTM mappings metadata is the study SDTM specification. To
develop the SDTM domains, {sdtm.oak} requires the user to prepare the
Study SDTM mappings metadata. Unlike the conventional SDTM
specification, which includes one tab per domain defining the target
(SDTM domain, Variables) to source (raw dataset, raw variables) and SDTM
mappings, the SDTM spec for {sdtm.oak} defines the source-to-target
relationship. For each source, the SDTM mapping, algorithms, and
associated metadata are defined. The table below presents the columns in
the SDTM mapping specification and its explanation.</p>
<div class="wide">


<table>
<colgroup>
<col width="9%" />
<col width="36%" />
<col width="40%" />
<col width="13%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Variable_Name</th>
<th align="left">Description_of_the_variable</th>
<th align="left">Example_Values</th>
<th align="left">Association_with_mapping_Algorithms</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">study_number</td>
<td align="left">Study Number</td>
<td align="left">test_study</td>
<td align="left">Generic Use</td>
</tr>
<tr class="even">
<td align="left">raw_source_model</td>
<td align="left">Data Collection model</td>
<td align="left">e-CRF or eDT</td>
<td align="left">Generic Use</td>
</tr>
<tr class="odd">
<td align="left">raw_dataset</td>
<td align="left">Name of the raw or source dataset</td>
<td align="left">VTLS1, DEM</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="even">
<td align="left">raw_dataset_ordinal</td>
<td align="left">Ordinal of the raw dataset as defined in EDC or eDT
specification</td>
<td align="left">1, 2, 3, etc</td>
<td align="left">Generic Use</td>
</tr>
<tr class="odd">
<td align="left">raw_dataset_label</td>
<td align="left">Label of the raw or source dataset</td>
<td align="left">Vital Signs,<br> Demographics</td>
<td align="left">Generic Use</td>
</tr>
<tr class="even">
<td align="left">raw_variable</td>
<td align="left">Name of the raw variable</td>
<td align="left">SEX_001, <br> BRTHDD</td>
<td align="left">Generic Use</td>
</tr>
<tr class="odd">
<td align="left">raw_variable_label</td>
<td align="left">Label of the raw variable</td>
<td align="left">Systolic Blood Pressure,<br>Birth Day</td>
<td align="left">Generic Use</td>
</tr>
<tr class="even">
<td align="left">raw_variable_ordinal</td>
<td align="left">Ordinal of the variable as defined in the eCRF or eDT
specification</td>
<td align="left">1, 2, 3, etc</td>
<td align="left">Generic Use</td>
</tr>
<tr class="odd">
<td align="left">raw_variable_type</td>
<td align="left">Type of the Raw Variable</td>
<td align="left">Text Box,<br> Date control</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="even">
<td align="left">raw_data_format</td>
<td align="left">Data format of the raw variable</td>
<td align="left">$200,<br> dd MON YYYY</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="odd">
<td align="left">study_specific</td>
<td align="left"><code>TRUE</code> indicates that the source is study
specific. <code>FALSE</code> indicates that the raw variable is part of
data standards</td>
<td align="left">TRUE, FALSE</td>
<td align="left">Generic Use</td>
</tr>
<tr class="even">
<td align="left">annotation_ordinal</td>
<td align="left">Ordinal of the SDTM mappings for the particular raw
source</td>
<td align="left">1, 2, 3, etc</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="odd">
<td align="left">mapping_is_dataset</td>
<td align="left">Indicates if the SDTM mapping is at the dataset level.
<code>TRUE</code> indicates that it is dataset level mapping.</td>
<td align="left">TRUE, FALSE</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="even">
<td align="left">annotation_text</td>
<td align="left">SDTM mapping text or annotation text</td>
<td align="left">VS.VSORRES when VSTESTCD = ‘SYSBP’</td>
<td align="left">Generic Use</td>
</tr>
<tr class="odd">
<td align="left">target_domain</td>
<td align="left">Name of the target domain.</td>
<td align="left">VS, MH</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="even">
<td align="left">target_sdtm_variable</td>
<td align="left">Name of the target SDTM variable</td>
<td align="left">VSORRES, MHSTDTC</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="odd">
<td align="left">target_sdtm_variable_role</td>
<td align="left">CDISC Role for the SDTM target variable defined in the
annotation.</td>
<td align="left">Topic Variable,<br>Grouping Qualifier,<br>Identifier
Variable</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="even">
<td align="left">target_sdtm_variable_codelist_code</td>
<td align="left">NCI or sponsor code of the codelist assigned to the
SDTM target variable defined in the annotation.</td>
<td align="left">C66742<br>C66790</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="odd">
<td align="left">target_sdtm_variable_ controlled_terms_or_format</td>
<td align="left">Controlled terms or format for the target variable
defined in the annotation (as defined per CDISC).
<code>target_sdtm_variable_controlled_terms_or_format</code> is required
for SDTM Define.xml</td>
<td align="left">(AGEU)<br>ISO 8601<br>(SEX)</td>
<td align="left">Generic Use</td>
</tr>
<tr class="even">
<td align="left">target_sdtm_variable_ordinal</td>
<td align="left">Ordinal of the target SDTM variable</td>
<td align="left">1, 2, 3</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="odd">
<td align="left">origin</td>
<td align="left">Origin of metadata source, values are subject to
controlled terminology</td>
<td align="left">Derived, <br>Assigned, <br>Collected,
<br>Predecessor</td>
<td align="left">Used for define.xml</td>
</tr>
<tr class="even">
<td align="left">mapping_algorithm</td>
<td align="left">Mapping Algorithm</td>
<td align="left">condition_add<br>assign_ct<br>ae_aerel<br>hardcode_ct</td>
<td align="left">Required for all mapping algorithms</td>
</tr>
<tr class="odd">
<td align="left">sub_algorithm</td>
<td align="left">The sub-algorithm (scenario) of the source-to-target
mapping</td>
<td align="left">assign_no_ct<br>hardcode_ct</td>
<td align="left">Only when Mapping Algorithm is
<br>condition_add<br>dataset_level</td>
</tr>
<tr class="even">
<td align="left">target_hardcoded_value</td>
<td align="left">Text (Hardcoded value) that applies to the target.</td>
<td align="left">ALZHEIMER’S DISEASE HISTORY</td>
<td align="left">assign_no_ct<br>hardcode_no_ct</td>
</tr>
<tr class="odd">
<td align="left">target_term_value</td>
<td align="left">CDISC Submission value or sponsor value which
represents a hardcoded text</td>
<td align="left">Y, <br>beats/min, <br>INFORMED CONSENT OBTAINED</td>
<td align="left">harcode_ct</td>
</tr>
<tr class="even">
<td align="left">condition_add_raw_dat</td>
<td align="left">Condition that has to be applied at a raw dataset
before applying a mapping. Can be a valid R filter statement.</td>
<td align="left">Map qualifier CMSTRTPT Annotation text is If MDPRIOR ==
1 then CM.CMSTRTPT = ‘BEFORE’ raw_dat parameter as condition_add(cm_raw,
MDPRIOR == 1)</td>
<td align="left">condition_add</td>
</tr>
<tr class="odd">
<td align="left">condition_add_tgt_dat</td>
<td align="left">Condition that has to be applied at a target dataset
before applying a mapping. Can be a valid R filter statement.</td>
<td align="left">Map qualifier CMDOSFRQ Annotation text is If CMTRT is
not null then map the collected value in raw dataset cm_raw and raw
variable MDFRQ to CMDOSFRQ tgt_dat parameter as condition_add(.,
!is.na(CMTRT))</td>
<td align="left">condition_add</td>
</tr>
<tr class="even">
<td align="left">merge_type</td>
<td align="left">Specifies the type of join</td>
<td align="left">left_join<br>right_join<br>full_join<br>visit_join<br>subject_join</td>
<td align="left">MERGE</td>
</tr>
<tr class="odd">
<td align="left">merge_left</td>
<td align="left">Specifies the left component of the merge</td>
<td align="left">VTLS1</td>
<td align="left">MERGE</td>
</tr>
<tr class="even">
<td align="left">merge_right</td>
<td align="left">Specifies the right component of the merge</td>
<td align="left">VACREC</td>
<td align="left">MERGE</td>
</tr>
<tr class="odd">
<td align="left">merge_condition</td>
<td align="left">Specify the condition of the join (e.g. a specific
variable that should match in the components of the merge)</td>
<td align="left">VTLS1.SUBJECT = VACREC.SUBJECT,<br>MD1.MDNUM =
VACREC.MDNUM</td>
<td align="left">MERGE</td>
</tr>
<tr class="even">
<td align="left">unduplicate_keys</td>
<td align="left">Raw variables that should be used to determine whether
an observation in the source data is a duplicate record and subject to
being removed</td>
<td align="left">VTLS1.SUBJECT,<br>VTLS1.DATAPAGEID</td>
<td align="left">REMOVE_DUP</td>
</tr>
<tr class="odd">
<td align="left">groupby_keys</td>
<td align="left">Raw Variables or aggregation functions (i.e. earliest,
latest) to group source data records before mapping to SDTM</td>
<td align="left">TXINF1.DATAPGID, <br>Earliest</td>
<td align="left">GROUP_BY</td>
</tr>
</tbody>
</table>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
